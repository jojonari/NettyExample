# 자바 네트워크 소녀 Netty

> * book : http://www.hanbit.co.kr/store/books/look.php?p_code=B2683487348
> * github : https://github.com/krisjey/netty.book.kor

실습예

* 1장
	- 실습예제는 java appication으로 실행해야 한다.
	- 네티는 이벤트를 인바운드이벤트와 아웃바운드 이벤트로 구분한 추상화 모델을 제공한다.
	* 에코서버 : 간단하게 클라이언트가 요청을 보내면 적당한 응답을 보내주는 서버

* 2장
	- 동기와 비동기의 정의
		* sync(동기) / Async(비동기)
		* 동기적 처리 : 순차적으로 일을 스스로 끝내 나가는 방식
		* 비동기적 처리 : 해야 할 일을 위임하고 기다리는 방식
	- 블로킹과 논블로킹 소켓
		* 블러킹 : 함수를 호출하고, 그 결과가 나올때까지 함수를 반환하지 않는다는 뜻이다.
		* 넌블러킹 : 블러킹과 반대로 결과가 나올 때까지 기다리지 않고(블러킹 되지 않고) 함수를 바로 반환된다.	
	- 이벤트 기반 프로그래밍
		* 사건 기반 프로그래밍(영어: Event-driven programming; EDP)은 비주얼 베이직과 같이, 사용자의 명령·마우스 클릭·다른 프로그램의 메시지·키보드 글쇠 입력 등의 ‘사건’에 따라, 제어 흐름이 결정되어 일을 하도록 하게끔 만들어진 프로그래밍 언어 방식을 뜻한다.

* 3장 
	- 부트스트랩의 논리적 구조
		* 전송계층(소켓 모드 및 I/O 종류)
		* 이벤트 루프(단일 스레드, 다중 스레드)
		* 채널 파이프라인 설정
		* 소켓 주소와 포트
		* 소켓 옵션
	- TCP와 SCTP
		* TCP  : 3 way handshake(SYN-ACK 구조)
		* SCTP : 4 way handshake(INIT-ACK, COOKIE-ECHO 구조)를 사용, 연결 정보에 쿠키를 삽입하여 DoS와 같은 네트워크 공격을 보호, 반닫힘 상태를 지원하지 않음

* 4장
	- 파이프라인 : 이벤트 전달
	- 이벤트 핸들러 : 이벤트 처리
	- 코덱 : 이벤트 핸들러 구현체
	- 네티 내부에서는 모든 데이터가 ByteBuf로 관리된다.
	- 인바운드 이벤트 발생 순서	
		1. 이벤트 루프에 채널 등록(channelRegistered)
		2. 채널 활성화(channelActive)
		3. 데이터 수신(channelRead)
		4. 데이터 수신 완료(channelReadComplete)
		5. 채널 비활성화(channellnactive)
		6. 이벤트 루프에서 채널 제거(channelUnregistered)
		
* 5장
	- 이벤트 루프 : 이벤트를 실행하기 위한 무한루프 스레드를 지칭
		* 객체에서 발생한 이벤트는 이벤트 큐에 입력되고 이벤트 루프는 이벤트 큐에 입력된 이벤트가 있을 때 해당 이벤트를 꺼내서 이벤트를 실행한다.
	- 다중 스레드 아키텍처는 자원의 효율 사용이라는 장점도 있지만 컨텍스트 스위칭 비용과 스레드 경합이라는 단점도 존재한다.
	- 다중 스레드에서 갖는 상태
		* 실행
		* 대기
		* 준비
		* 슬립
		* 지연
	- 컨텍스트 스위칭 : 운영체제는 현재 상태가 대기, 슬립, 지연인 스레드 중의 하나를 선택하여 실행 상태로 바꾸는데 이때 스레드가 가진 스택 정보를 현재 코어의 레지스터로 복사하는 작업이 이루어지며 이것을 컨텍스트 스위칭이라고 한다.
	- 퓨처 패턴 : 미래에 완료될 작업을 등록하고 처리 결과를 확인하는 객체를 통해서 작업의 완료를 확인하는 패턴

* 6장
	- 자바 바이트 버퍼	
		* 힙 버퍼와 다이렉트 버퍼로 나뉜다.
			+ 다이렉트 버퍼가 생성시간은 길지만 더 빠른 읽기 쓰기 성능을 제공
			+ 다이렉트 버퍼는 운영체제의 커널 영역에 바이트 버퍼를 생성한다.
		* 3가지 속성
			+ capacity : 버퍼에 저장할 수 있는 데이터의 최대 크기로 한 번 정하면 변경이 불가능하다.
			+ position : 읽기 또는 쓰기가 작업 중인 위치를 나타낸다.
			+ limit : 읽고 쓸 수 있는 버퍼 공간의 최대치를 나타낸다. 이값을 capacity보다 크게 설정할 수 없다.
	- 네티 바이트 버퍼
		* 특징 
			+ 별도의 읽기 인덱스와 쓰기 인덱스
			+ flip 메서드 없이 읽기 쓰기 가능
			+ 가변 바이트 버퍼
			+ 바이트 버퍼 풀
			+ 복합 버퍼
			+ 자바의 바이트 버퍼와 네티의 바이트 버퍼 상호 호환 변환
		* 바이트 버퍼 풀링 : 버퍼를 빈번히 할당하고 해제할 때 일어나는 가비지 컬렉션 횟수를 감소시킬수 있다.
	- 가비지 컬렉션 : 유요한 참조가 없는 객체가 점유하고 있던 메모리를 가상 머신으로 돌려주는 것이다. 즉 자바 가상 머신이 더 이상 객체를 할당할 메모리가 없다고 판단하면 자동으로 가비지 컬렉션을 수행한다.
	- 엔디안
		* 빅-엔디안 : 낮은 주소에 상위 바이트 부터 기록
		* 리틀-엔디안 : 낮은 주소에 하위 바이트 부터 기록
		* 2바이트 빅엔디안인 0x0001을 리틀엔디안으로 변환하면 0x0100
		
* 7장 
	- 네티에 ssl/tls를 적용할 수 있다.
	- 네트워크로 전송된 데이터를 가로채는 것을 네트워크 데이터 캡쳐라고 부른다.
	- Forward Proxy : 클라이언트가 타겟서버에 접근하고자 할때, 클라이언트는 타겟서버의 주소를 프락시에 전달하여, 프락시가 요청된 내용을 가져오는 방식
	- Reverse Proxy : 클라이언트는 Reverse Proxy 로 설정된 서버의 주소로 데이타를 요청하게 되며, Reverse Proxy는 이 요청을 받아서 "배후"의 서버에 데이타를
요청하여 받은 다음 클라이언트에 전달하게 됨.
	- 클라이언트가 접속을 요청하는 서버의 주소가 프록시 서면이면 리버스 프록시, 목적지 서버의 주소이면 포워드 프록시로 구분
	- 단방향 암호화는 한 번 암호화된 암호문은 다시 평문으로 복호화할 수 없다.
	- 양방향 암호화는 암호문을 복호화하여 평문으로 복원 할 수 있다.
	- 대칭키 암호화 : 암호화/복호화에 같은 암호화 키가 사용됨
	- 비대칭 암호화 : 암호화/복호화에 서로 다른 암호화 키가 사용
	- openssl을 사용하여 RSA생성
		+ 개인키 : $openssl genrsa -aes256 -out privatekey.pem 2048
		+ 공개키 : $openssl req -new -key privatekey.pem -out netty.csr
		+ 개인키를 생성후 개인키를 토대로 공개키 생성 
		